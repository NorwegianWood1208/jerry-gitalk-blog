(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{554:function(e,n,t){"use strict";t.r(n);var r=t(15),s=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("关于后台管理系统的路由，想花一点时间，彻底的整理一份实现动态路由的点点滴滴。")]),e._v(" "),t("p",[e._v("首先声明，这篇文章是基于花裤衩大神的《手摸手，带你用vue撸后台》，在他项目的基础上，帮助想要实现动态路由的小伙伴，来写的一篇使用笔记。")]),e._v(" "),t("blockquote",[t("p",[e._v("https://segmentfault.com/a/1190000009506097#item-3")])]),e._v(" "),t("h3",{attrs:{id:"为什么要实现动态路由"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么要实现动态路由"}},[e._v("#")]),e._v(" 为什么要实现动态路由?")]),e._v(" "),t("p",[e._v("我们在开发后台管理系统的过程中，会有不同的人来操作系统，有admin（管理员）、superAdmin(超管)，还会有各种运营人员、财务人员。为了区别这些人员，我们会给不同的人分配不一样的角色，从而来展示不同的菜单，这个就必须要通过动态路由来实现。")]),e._v(" "),t("h3",{attrs:{id:"主流的实现方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主流的实现方式"}},[e._v("#")]),e._v(" 主流的实现方式：")]),e._v(" "),t("p",[e._v("简单聊一下两种方式的优势，毕竟如果你从来没做过，说再多也看不明白，还是得看代码")]),e._v(" "),t("h4",{attrs:{id:"前端控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端控制"}},[e._v("#")]),e._v(" 前端控制")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("1、不用后端帮助，路由表维护在前端\n2、逻辑相对比较简单，比较容易上手\n")])])]),t("h4",{attrs:{id:"_2、后端控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、后端控制"}},[e._v("#")]),e._v(" 2、后端控制")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("1、相对更安全一点\n2、路由表维护在数据库\n")])])]),t("h1",{attrs:{id:"一、前端控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、前端控制"}},[e._v("#")]),e._v(" 一、前端控制")]),e._v(" "),t("p",[e._v("花裤衩大神的方案是前端控制，他的核心是通过路由的meta属性，通过role来控制路由的加载。具体的实现方案：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("1、根据登录用户的账号，返回前端用户的角色\n\n2、前端根据用户的角色，跟路由表的meta.role进行匹配\n\n3、讲匹配到的路由形成可访问路由\n")])])]),t("p",[e._v("具体的代码逻辑：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("1、把静态路由和动态路由分别写在router.js\n\n2、在vuex维护一个state，通过配角色来控制菜单显不显示\n\n3、新建一个路由守卫函数，可以在main.js，也可以抽离出来一个文件\n\n4、侧边栏的可以从vuex里面取数据来进行渲染\n")])])]),t("h2",{attrs:{id:"核心代码一共四个文件-基本都会加上源码和解释"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#核心代码一共四个文件-基本都会加上源码和解释"}},[e._v("#")]),e._v(" 核心代码一共四个文件，基本都会加上源码和解释：")]),e._v(" "),t("h4",{attrs:{id:"_1、在router-js文件-把静态路由和动态路由分别写在router-js"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、在router-js文件-把静态路由和动态路由分别写在router-js"}},[e._v("#")]),e._v(" 1、在router.js文件（把静态路由和动态路由分别写在router.js）")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("import Vue from 'vue'\nimport Router from 'vue-router'\n\nVue.use(Router)\n\nimport Layout from '@/layout'\n\n// constantRoutes  静态路由，主要是登录页、404页等不需要动态的路由\n\nexport const constantRoutes = [\n  {\n    path: '/redirect',\n    component: Layout,\n    hidden: true,\n    children: [\n      {\n        path: '/redirect/:path*',\n        component: () => import('@/views/redirect/index')\n      }\n    ]\n  },\n  {\n    path: '/login',\n    component: () => import('@/views/login/index'),\n    hidden: true\n  },\n  {\n    path: '/404',\n    component: () => import('@/views/error-page/404'),\n    hidden: true\n  },\n  {\n    path: '/401',\n    component: () => import('@/views/error-page/401'),\n    hidden: true\n  }\n] \n\n// asyncRoutes 动态路由\nexport const asyncRoutes = [\n  {\n    path: '/permission',\n    component: Layout,\n    redirect: '/permission/page',\n    alwaysShow: true, \n    name: 'Permission',\n    meta: {\n      title: 'Permission',\n      icon: 'lock',\n      // 核心代码，可以通过配的角色来进行遍历，从而是否展示\n      // 这个意思就是admin、editor这两个角色，这个菜单是可以显示\n      roles: ['admin', 'editor']\n    },\n    children: [\n      {\n        path: 'page',\n        component: () => import('@/views/permission/page'),\n        name: 'PagePermission',\n        meta: {\n          title: 'Page Permission',\n          // 这个意思就是只有admin能展示\n          roles: ['admin']\n        }\n      }\n     ]\n    }\n]\n\nconst createRouter = () => new Router({\n  scrollBehavior: () => ({ y: 0 }),\n  routes: constantRoutes\n})\n\nconst router = createRouter()\n\n// 这个是重置路由用的，很有用，别看这么几行代码\nexport function resetRouter() {\n  const newRouter = createRouter()\n  router.matcher = newRouter.matcher \n}\n\nexport default router\n")])])]),t("h4",{attrs:{id:"_2、store-permission-js-在vuex维护一个state-通过配角色来控制菜单显不显示"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、store-permission-js-在vuex维护一个state-通过配角色来控制菜单显不显示"}},[e._v("#")]),e._v(" 2、store/permission.js(在vuex维护一个state，通过配角色来控制菜单显不显示)")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("import { asyncRoutes, constantRoutes } from '@/router'\n\n// 这个方法是用来把角色和route.meta.role来进行匹配\nfunction hasPermission(roles, route) {\n  if (route.meta && route.meta.roles) {\n    return roles.some(role => route.meta.roles.includes(role))\n  } else {\n    return true\n  }\n}\n\n\n// 这个方法是通过递归来遍历路由，把有权限的路由给遍历出来\nexport function filterAsyncRoutes(routes, roles) {\n  const res = []\n\n  routes.forEach(route => {\n    const tmp = { ...route }\n    if (hasPermission(roles, tmp)) {\n      if (tmp.children) {\n        tmp.children = filterAsyncRoutes(tmp.children, roles)\n      }\n      res.push(tmp)\n    }\n  })\n\n  return res\n}\n\nconst state = {\n  routes: [],\n  addRoutes: []\n}\n\nconst mutations = {\n  SET_ROUTES: (state, routes) => {\n    // 这个地方维护了两个状态一个是addRouters，一个是routes\n    state.addRoutes = routes\n    state.routes = constantRoutes.concat(routes)\n  }\n}\n\nconst actions = {\n  generateRoutes({ commit }, roles) {\n    return new Promise(resolve => {\n      let accessedRoutes\n      if (roles.includes('admin')) {\n        accessedRoutes = asyncRoutes || []\n      } else {\n        // 核心代码，把路由和获取到的角色(后台获取的)传进去进行匹配\n        accessedRoutes = filterAsyncRoutes(asyncRoutes, roles)\n      }\n      // 把匹配完有权限的路由给set到vuex里面\n      commit('SET_ROUTES', accessedRoutes)\n      resolve(accessedRoutes)\n    })\n  }\n}\n\nexport default {\n  namespaced: true,\n  state,\n  mutations,\n  actions\n}\n")])])]),t("h3",{attrs:{id:"_3、src-permission-js-新建一个路由守卫函数-可以在main-js-也可以抽离出来一个文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、src-permission-js-新建一个路由守卫函数-可以在main-js-也可以抽离出来一个文件"}},[e._v("#")]),e._v(" 3、src/permission.js（新建一个路由守卫函数，可以在main.js，也可以抽离出来一个文件）")]),e._v(" "),t("p",[e._v("这里面的代码主要是控制路由跳转之前，先查一下有哪些可访问的路由，登录以后跳转的逻辑可以在这个地方写")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("// permission.js\nrouter.beforeEach((to, from, next) => {\n  if (store.getters.token) { // 判断是否有token\n    if (to.path === '/login') {\n      next({ path: '/' });\n    } else {\n        // 判断当前用户是否已拉取完user_info信息\n      if (store.getters.roles.length === 0) {\n        store.dispatch('GetInfo').then(res => { // 拉取info\n          const roles = res.data.role;\n          // 把获取到的role传进去进行匹配，生成可以访问的路由\n          store.dispatch('GenerateRoutes', { roles }).then(() => { \n            // 动态添加可访问路由表（核心代码，没有它啥也干不了）\n            router.addRoutes(store.getters.addRouters)\n            \n            // hack方法 确保addRoutes已完成\n            next({ ...to, replace: true })\n          })\n        }).catch(err => {\n          console.log(err);\n        });\n      } else {\n        next() //当有用户权限的时候，说明所有可访问路由已生成 如访问没权限的全面会自动进入404页面\n      }\n    }\n  } else {\n    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入\n      next();\n    } else {\n      next('/login'); // 否则全部重定向到登录页\n    }\n  }\n})\n")])])]),t("h3",{attrs:{id:"_4、侧边栏的可以从vuex里面取数据来进行渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、侧边栏的可以从vuex里面取数据来进行渲染"}},[e._v("#")]),e._v(" 4、侧边栏的可以从vuex里面取数据来进行渲染")]),e._v(" "),t("p",[e._v("核心代码是从router取可以用的路由对象，来进行侧边栏的渲染，不管是前端动态加载还是后端动态加载路由，这个代码都是一样的")]),e._v(" "),t("h5",{attrs:{id:"layout-components-siderbar-index-vue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#layout-components-siderbar-index-vue"}},[e._v("#")]),e._v(" layout/components/siderbar/index.vue")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('<el-menu\n:default-active="activeMenu"\n:collapse="isCollapse"\n:background-color="variables.menuBg"\n:text-color="variables.menuText"\n:unique-opened="false"\n:active-text-color="variables.menuActiveText"\n:collapse-transition="false"\nmode="vertical"\n>\n    // 把取到的路由进行循环作为参数传给子组件\n    <sidebar-item v-for="route in routes" :key="route.path" :item="route" :base-path="route.path" />\n</el-menu>\n// 获取有权限的路由\nroutes() {\n  return this.$router.options.routes\n}\n')])])]),t("h5",{attrs:{id:"layout-components-siderbar-siderbaritem-vue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#layout-components-siderbar-siderbaritem-vue"}},[e._v("#")]),e._v(" layout/components/siderbar/siderbarItem.vue")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('  <template slot="title">\n    <item v-if="item.meta" :icon="item.meta && item.meta.icon" :title="item.meta.title" />\n  </template>\n  <sidebar-item\n    v-for="child in item.children"\n    :key="child.path"\n    :is-nest="true"\n    :item="child"\n    :base-path="resolvePath(child.path)"\n    class="nest-menu"\n  />\n\n  props: {\n    // route object\n    item: {\n      type: Object,\n      required: true\n    },\n    isNest: {\n      type: Boolean,\n      default: false\n    },\n    basePath: {\n      type: String,\n      default: \'\'\n    }\n  }\n')])])]),t("p",[e._v("前端控制路由，逻辑相对简单，后端只需要存这个用户的角色就可以了，前端拿用户的角色进行匹配。但是如果新增角色，就会非常痛苦，每一个都要加。")]),e._v(" "),t("h1",{attrs:{id:"二、后端控制路由"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、后端控制路由"}},[e._v("#")]),e._v(" 二、后端控制路由")]),e._v(" "),t("p",[e._v("后端控制路由是大部分后台管理系统的解决方案，我们公司也是通过这种方法管理路由的。具体的思路是这样的：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("1、用户登录以后，后端根据该用户的角色，直接生成可访问的路由数据，注意这个地方是数据\n\n2、前端根据后端返回的路由数据，转成自己需要的路由结构\n")])])]),t("p",[e._v("具体的代码逻辑：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("1、router.js里面只放一些静态的路由，login、404之类\n\n2、整理一份数据结构，存到表里\n\n3、从后端获取路由数据，写一个数据转换的方法，讲数据转成可访问的路由\n\n4、也是维护一个vuex状态，将转换好的路由存到vuex里面\n\n5、侧边栏也是从路由取数据进行渲染\n")])])]),t("p",[e._v("因为前段控制和后端控制，后面的流程大部分都是一样的，所以这个地方只看看前面不一样的流程：")]),e._v(" "),t("h3",{attrs:{id:"_1、store-permission-js-在vuex里面发送请求获取数据"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、store-permission-js-在vuex里面发送请求获取数据"}},[e._v("#")]),e._v(" 1、store/permission.js，在vuex里面发送请求获取数据")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("GenerateRoutes({ commit }, data) {\n  return new Promise((resolve, reject) => {\n    getRoute(data).then(res => {\n     // 将获取到的数据进行一个转换，然后存到vuex里\n      const accessedRouters = arrayToMenu(res.data)\n      accessedRouters.concat([{ path: '*', redirect: '/404', hidden: true }])\n      commit('SET_ROUTERS', accessedRouters)\n      resolve()\n    }).catch(error => {\n      reject(error)\n    })\n  })\n}\n")])])]),t("h3",{attrs:{id:"_2、整理一份数据结构-存到表里"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、整理一份数据结构-存到表里"}},[e._v("#")]),e._v(" 2、整理一份数据结构，存到表里")]),e._v(" "),t("p",[e._v("我们知道vue的router规定的数据结构是这样的：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("{\n    path: '/form',\n    component: Layout,\n    children: [\n      {\n        path: 'index',\n        name: 'Form',\n        component: () => import('@/views/form/index'),\n        meta: { title: 'Form', icon: 'form' }\n      }\n    ]\n}\n")])])]),t("p",[e._v("所以，一级菜单有几个参数必须要有：id、path、name、component、title，二级菜单children是一个数组，是子父级的关系，所以可以给加一个fid或者parentId，来进行匹配，后面写转换方法的时候会详细解释，数据格式大概就是这样：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('// 一级菜单\n// parentId为0的就可以当做一级菜单，id最好是可以选4位数，至于为什么等你开发项目的时候就知道了\n{\n    id: 1300\n    parentId: 0\n    title: "企业管理"\n    path: "/enterprise"\n    hidden: false\n    component: null\n    hidden: false\n    name: "enterprise"\n}，\n\n// 二级菜单\n// parentId不为0的，就可以拿parentId跟一级菜单的id去匹配，匹配上的就push到children里面\n{\n    id: 1307\n    parentId: 1300\n    title: "商户信息"\n    hidden: false\n    path: "merchantInfo"\n    component: "enterprise/merchantInfo" // 要跟本地的文件地址匹配上\n    hidden: false\n    name: "merchantInfo"\n}\n')])])]),t("h3",{attrs:{id:"_3、写一个转化方法-把获取到的数据转换成router结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、写一个转化方法-把获取到的数据转换成router结构"}},[e._v("#")]),e._v(" 3、写一个转化方法，把获取到的数据转换成router结构")]),e._v(" "),t("p",[e._v("刚才获取到的数据无法直接转成router进行渲染，需要一个arrayToMenu的方法，刚才也说了一些思路，下面就一起分析下这个方法：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("export function arrayToMenu(array) {\n  const nodes = []\n  // 获取顶级节点\n  for (let i = 0; i < array.length; i++) {\n    const row = array[i]\n    // 这个exists方法就是判断下有没有子级\n    if (!exists(array, row.parentId)) {\n      nodes.push({\n        path: row.path, // 路由地址\n        hidden: row.hidden, // 全部携程true就行，如果后端没配\n        component: Layout, // 一般就是匹配你文件的component\n        name: row.name, // 路由名称\n        meta: { title: row.title, icon: row.name }, // title就是显示的名字\n        id: row.id, // 路由的id\n        redirect: 'noredirect'\n      })\n    }\n  }\n  const toDo = Array.from(nodes)\n  while (toDo.length) {\n    const node = toDo.shift()\n    // 获取子节点\n    for (let i = 0; i < array.length; i++) {\n      const row = array[i]\n      // parentId等于哪个父级的id，就push到哪个\n      if (row.parentId === node.id) {\n        const child = {\n          path: row.path,\n          name: row.name,\n          hidden: row.hidden,\n          // 核心代码，因为二级路由的component是需要匹配页面的\n          component: require('@/views/' + row.component + '/index.vue'),\n          meta: { title: row.title, icon: row.name },\n          id: row.id\n        }\n        if (node.children) {\n          node.children.push(child)\n        } else {\n          node.children = [child]\n        }\n        toDo.push(child)\n      }\n    }\n  }\n  return nodes\n}\n// 看下有没有子级\nfunction exists(rows, parentId) {\n  for (let i = 0; i < rows.length; i++) {\n    if (rows[i].id === parentId) return true\n  }\n  return false\n}\n")])])]),t("p",[e._v("侧边栏的代码跟静态的代码是一样的，就不再说一遍了")]),e._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("p",[e._v("动态路由究竟是前端控制好，还是后端控制好？只能说各有各的优势，毕竟业务场景也不一样，大家可以动手来试一下。代码还有很多值得优化的地方，欢迎各位大神批评指正。")]),e._v(" "),t("p",[e._v("个人公众号：小Jerry有话说")]),e._v(" "),t("p",[e._v("也欢迎关注我的个人公众号，分享一些有趣的前端知识。")])])}),[],!1,null,null,null);n.default=s.exports}}]);