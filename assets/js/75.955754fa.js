(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{557:function(e,n,s){"use strict";s.r(n);var r=s(15),o=Object(r.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("上一篇呢，主要是聊了聊同步、异步，他们各自引申出来的‘执行栈’、‘消息队列’，以及‘宏任务’、‘微任务’，如果大家对这几个概念不太了解，可以去这个链接：")]),e._v(" "),s("p",[e._v("https://www.jianshu.com/p/61e7844e68d8")]),e._v(" "),s("p",[e._v("上一篇咱们说了，宏任务与微任务都是异步的，其中包括ajax请求、计时器等等，我们初步的了解一下promise，知道他是解决异步的一种方式，那么我们常用的一共有哪几种方法呢?")]),e._v(" "),s("p",[e._v("因为涉及的知识点比较多，这篇文章主要是讲一下，回调函数和promise：")]),e._v(" "),s("h4",{attrs:{id:"一、回调函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、回调函数"}},[e._v("#")]),e._v(" 一、回调函数")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("先上代码：\nfunction f2() {\n    console.log('2222')\n}\nfunction f1(callback){\n    console.log('111')\n　　setTimeout(function () {\n　　　　callback(); \n　　}, 5000);\n　　console.log('3333')\n}\nf1(f2);\n\n先看下打印值是：\n111\n3333\n五秒后2222\n")])])]),s("p",[e._v("相当于主线程执行完了，会通过回调函数去调用f2函数，这个没什么毛病。但是看下下面的例子：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("现在我们读取一个文件，fileReader就是一个异步请求\n\n// 这个异步请求就是通过回调函数的方式获取的\n\nvar reader = new FileReader()\nvar file = input.files[0]\nreader.readAsText(file, 'utf-8',function(err, data){\n    if(err){\n        console.log(err)\n    } else {\n        console.log(data)\n    }\n})\n")])])]),s("p",[e._v("现在看起来也很不错，但是如果文件上传出错了，我们还要在回调里面做判断，要是我们读取完这个文件接着要读取多个文件呢？是不是应该这么写：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("读取完文件1之后再接着读取文件2、3\n\nvar reader = new FileReader()\nvar file = input.files[0]\nreader.readAsText(file1, 'utf-8',function(err1, data1){\n    if(err1){\n        console.log(err1)\n    } else {\n        console.log(data1)\n    }\n    reader.readAsText(file2, 'utf-8',function(err2, data2){\n        if(err2){\n            console.log(err2)\n        } else {\n            console.log(data2)\n        }\n        reader.readAsText(file3, 'utf-8',function(err3, data3){\n            if(err3){\n                console.log(err3)\n            } else {\n                console.log(data3)\n            }\n        })\n    })\n})\n")])])]),s("p",[e._v("这么写可以实现需求，但是这个代码的可读性就比较差，看起来就不那么优雅，也就是我们常说的‘回调地狱’。那么怎么破解这种嵌套式的回调呢？ES6为我们提供了promise：")]),e._v(" "),s("h4",{attrs:{id:"二、promise"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、promise"}},[e._v("#")]),e._v(" 二、promise")]),e._v(" "),s("p",[e._v("首先我们从字面意思上理解一下什么是promise？promise可以翻译成承诺、保证，这个地方你可以理解为：")]),e._v(" "),s("p",[e._v("女朋友让我干了一件事，虽然还没干完，但是我保证这件事会有一个结果给你，成功（fulfiled）或者失败（rejected），还有一个等待状态（pending）。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("还是先上例子\n\nlet promise = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve(2000) // 成功以后这个resolve会把成功的结果捕捉到\n        // reject(2000) // 失败以后这个reject会把失败的结果捕捉到\n    }, 1000)\n    console.log(1111)\n})\n\npromise.then(res => {\n    console.log(res) // then里面第一个参数就能拿到捕捉到的成功结果\n}, err =>{\n    console.log(res)// then里面第二个参数就能拿到捕捉到的失败结果\n})\n\n打印结果：\n\n1111\n2000（一秒以后）\n")])])]),s("h5",{attrs:{id:"_1、then链式操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、then链式操作"}},[e._v("#")]),e._v(" 1、then链式操作")]),e._v(" "),s("p",[e._v("Promise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。")]),e._v(" "),s("p",[e._v("then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调，这个上面的例子说的很明白了，第二个参数捕捉的就是失败的回调。")]),e._v(" "),s("p",[e._v("两个函数只会有一个被调用，这句话怎么理解呢？\n女朋友让你去做西红柿鸡蛋汤，你要么就去做，要么就不做，叫外卖，肯定没有第三种选择\n。")]),e._v(" "),s("p",[e._v("函数的返回值将被用作创建then返回的Promise对象。这句话应该怎么理解呢？还是上例子：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("let promise = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        resolve(2000)\n    }, 1000)\n    console.log(1111)\n})\npromise.then(res => {\n    console.log(res) // 这个地方会打印捕捉到的2000\n    return res + 1000 // 这个函数的返回值，返回的就是这个promise对象捕捉到的成功的值\n}).then(res => {\n    console.log(res) //这个地方打印的就是上一个promise对象return的值\n})\n\n所以打印顺序应该是：\n\n1111\n2000\n3000\n")])])]),s("p",[e._v("刚才我们看到了then接受两个参数，一个是成功的回调、一个是失败的回调，看起来好像也不是那么优雅，promise里除了then还提供了catch方法：")]),e._v(" "),s("h5",{attrs:{id:"_2、catch捕捉操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、catch捕捉操作"}},[e._v("#")]),e._v(" 2、catch捕捉操作")]),e._v(" "),s("p",[e._v("这个catch就是专门捕捉错误的回调的，还是先看例子：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("let promise = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        reject(2000) // 失败以后这个reject会把失败的结果捕捉到\n    }, 1000)\n    console.log(1111)\n})\npromise.catch(res => {\n    console.log(res) // catch里面就能拿到捕捉到的失败结果\n})\n\n打印结果：\n\n1111\n2000（一秒以后）\n")])])]),s("p",[e._v("除了then和catch之外，promise还有两个语法，all和race，我们也简单用一下：")]),e._v(" "),s("h5",{attrs:{id:"_3、all"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、all"}},[e._v("#")]),e._v(" 3、all")]),e._v(" "),s("p",[e._v("现在我们有这么一个需求，一共有三个接口A、B、C，必须三个接口都成功以后，才能发起第四个请求，怎么实现呢？")]),e._v(" "),s("h5",{attrs:{id:"链式调用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链式调用"}},[e._v("#")]),e._v(" 链式调用")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("let getInfoA = new Promise((resolve, reject) => {\n    console.log('小A开始执行了')\n    resolve()\n}).then(res => {\n    let getInfoB = new Promise((resolve, reject) => {\n        console.log('小B开始执行了')\n        resolve()\n    }).then(res => {\n        let getInfoC = new Promise((resolve, reject) => {\n            console.log('小C开始执行了')\n            resolve()\n        }).then(res => {\n            console.log('全都执行完了！')\n        })\n    })\n})\n")])])]),s("p",[e._v("一层套一层的，好像不是那么优雅")]),e._v(" "),s("h5",{attrs:{id:"all"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#all"}},[e._v("#")]),e._v(" all")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("let getInfoA = new Promise((resolve, reject) => {\n    console.log('小A开始执行了')\n    resolve()\n})\nlet getInfoB = new Promise((resolve, reject) => {\n    console.log('小B开始执行了')\n    resolve()\n})\nlet getInfoC = new Promise((resolve, reject) => {\n    console.log('小C开始执行了')\n    resolve()\n})\nPromise.all([getInfoA, getInfoB, getInfoC]).then(res => {\n   console.log('全都执行完了！')\n})\n")])])]),s("p",[e._v("接收一个Promise对象组成的数组作为参数，当这个数组所有的Promise对象状态都变成resolved或者rejected的时候，它才会去调用then方法。非常完美，非常优雅。")]),e._v(" "),s("h5",{attrs:{id:"_4、race"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4、race"}},[e._v("#")]),e._v(" 4、race")]),e._v(" "),s("p",[e._v("现在又有一个需求，同样是接口A、B、C，只要有一个响应了，我就可以调接口D，那么怎么实现呢？")]),e._v(" "),s("p",[e._v("1、传统方式")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("let getInfoA = new Promise((resolve, reject) => {\n    console.log('小A开始执行了')\n    setTimeout((err => {\n        resolve('小A最快')\n    }),1000)\n}).then(res =>{\n    console.log(res)\n})\nlet getInfoB = new Promise((resolve, reject) => {\n    console.log('小B开始执行了')\n    setTimeout((err => {\n        resolve('小B最快')\n    }),1001)\n}).then(res =>{\n    console.log(res)\n})\nlet getInfoC = new Promise((resolve, reject) => {\n    console.log('小C开始执行了')\n    setTimeout((err => {\n        resolve('小C最快')\n    }),1002)\n}).then(res =>{\n    console.log(res)\n})\n\n打印结果\n\n小A开始执行了\n小B开始执行了\n小C开始执行了\n小A最快\n")])])]),s("p",[e._v("这个方法得写三遍，好像也不是那么优雅，一起来看下race应该怎么写？")]),e._v(" "),s("p",[e._v("2、race")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("let getInfoA = new Promise((resolve, reject) => {\n    console.log('小A开始执行了')\n    setTimeout((err => {\n        resolve('小A最快')\n    }),1000)\n})\nlet getInfoB = new Promise((resolve, reject) => {\n    console.log('小B开始执行了')\n    setTimeout((err => {\n        resolve('小B最快')\n    }),1001)\n})\nlet getInfoC = new Promise((resolve, reject) => {\n    console.log('小C开始执行了')\n    setTimeout((err => {\n        resolve('小C最快')\n    }),1002)\n})\nPromise.race([getInfoA, getInfoB, getInfoC]).then(res => {\n    console.log(res)\n})\n\n打印结果\n\n小A开始执行了\n小B开始执行了\n小C开始执行了\n小A最快\n")])])]),s("p",[e._v("与Promise.all相似的是，Promise.race都是以一个Promise对象组成的数组作为参数，不同的是，只要当数组中的其中一个Promsie状态变成resolved或者rejected时，就可以调用.then方法了。")]),e._v(" "),s("h5",{attrs:{id:"promise是es6用来解决异步的一个方法-现在用的已经比较广泛了-像我们经常用的axios-他就是用promise封装的-用起来非常方便。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise是es6用来解决异步的一个方法-现在用的已经比较广泛了-像我们经常用的axios-他就是用promise封装的-用起来非常方便。"}},[e._v("#")]),e._v(" promise是ES6用来解决异步的一个方法，现在用的已经比较广泛了，像我们经常用的axios，他就是用promise封装的，用起来非常方便。")]),e._v(" "),s("p",[e._v("除了promise，ES6还为我们提供了终极大招async、await，因为这两个知识块比较大，所以我们准备下一篇文章讲。")])])}),[],!1,null,null,null);n.default=o.exports}}]);