(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{553:function(a,t,e){"use strict";e.r(t);var s=e(20),n=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("p",[a._v("上篇文章聊了js两种数据类型的区别以及基本数据类型，这篇文章主要聊一下js的引用数据类型、包装对象、js的强转换、隐性数据类型转换。")]),a._v(" "),e("h1",{attrs:{id:"一、引用数据类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、引用数据类型"}},[a._v("#")]),a._v(" 一、引用数据类型")]),a._v(" "),e("p",[a._v("在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。")]),a._v(" "),e("p",[a._v("除了对象，引用数据类型还有很多：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("Array 数组\nDate 日期\nRegExp 正则\nFunction 函数\n")])])]),e("p",[a._v("除了上面的数据类型，还有三个比较特殊的（基本数据类型的包装对象）：")]),a._v(" "),e("h3",{attrs:{id:"包装对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#包装对象"}},[a._v("#")]),a._v(" 包装对象")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("Boolean\nNumber\nString\n")])])]),e("p",[a._v("大家可能遇到过一道面试题：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("let num1 = 3\nlet num2 = new Number(3)\nconsole.log(num === num2)  // false\n")])])]),e("p",[a._v("这个Number()就是基本数据类型的number的包装对象:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("typeof(num1) // number\ntypeof(num2) // object\n")])])]),e("p",[a._v("这两个不是一个东西，当然也不相等了，那么我们就来搞清楚，这个包装对象到底是干什么的？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("let str = 'wanghuahua'\nlet str1 = str.substr(0, 4)\nconsole.log(str1) // wang\nconsole.log(String.substr) // undefined\n")])])]),e("p",[a._v("刚才调用substr方法截取了一下str这个字符串，str是基本数据类型，打印String的substr方法是undefined，这说明String是没有substr方法的，但是为什么能够截取呢？")]),a._v(" "),e("p",[a._v("这中间有一个计算机的操作，我们把它称作‘加工厂’，那么这个加工厂进行了哪些操作呢？（重点）")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("1、原材料进厂：把基本数据类型转成包装对象\n\n因为基本数据类型是没有方法的，如果你想操作基本数据类型，那就必须转成包装对象\n\n2、加工：调用substr的相关方法\n\n包装对象是可以加方法和属性，所以这个时候包装对象会调用方法进行操作\n\n3、成品出厂：包装对象转成基本数据类型\n\nECMAScript规范中提供了toPrimitive原则，所以这个地方会遵从toPrimitive原则进行转换。\n")])])]),e("p",[a._v("上篇文章说到了，这个js弱类型语言把相当多的操作都交给了计算机，这个地方就是一个明显的栗子，这些操作就都交给了计算机，相对来说增加了计算机的负担。")]),a._v(" "),e("p",[a._v("包装对象的由来，其实也没有那么复杂，就是为了处理基本数据类型的数据，加了中间的一层。")]),a._v(" "),e("p",[a._v("刚才在说成品出厂的时候，聊到了toPrimitive，toPrimitive就是我们常说的js强制转换：")]),a._v(" "),e("h1",{attrs:{id:"二、js强制转换"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、js强制转换"}},[a._v("#")]),a._v(" 二、js强制转换")]),a._v(" "),e("p",[a._v("所谓强制转换，就是人为的进行转换：")]),a._v(" "),e("h3",{attrs:{id:"一-tostring-转成字符串"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一-tostring-转成字符串"}},[a._v("#")]),a._v(" （一）toString() 转成字符串")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("let num2 = new String('hhh')\nconsole.log(num2.toString()) // hhh\n")])])]),e("p",[a._v("每个对象都有一个 toString()方法，当对象被表示为文本值时或者当以期望字符串的方式引用对象时，该方法被自动调用。")]),a._v(" "),e("p",[a._v("有时候会有一些非常恶心的面试题，这儿也列举几个不常见的：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("console.log(null.toString()) // 报错\nconsole.log(undefined.toString()) // 报错\nconsole.log(true.toString()) // 'true'\nlet a = 4\nconsole.log(a.toString()) // 4\nconsole.log('hhh'.toString()) // 'hhh'\nconsole.log(Symbol().toString()) // 报错\n")])])]),e("p",[a._v("除此之外，toString()还接收数字参数，来代表转换的进制：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("二进制：.toString(2);\n\n八进制：.toString(8);\n\n十进制：.toString(10);\n\n十六进制：.toString(16);\n")])])]),e("h3",{attrs:{id:"二-valueof-返回原始值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二-valueof-返回原始值"}},[a._v("#")]),a._v(" （二）valueOf() 返回原始值")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("let num2 = new String('hhh')\nconsole.log(num2.valueOf())  // hhh\n")])])]),e("p",[a._v("JavaScript 调用 valueOf()方法用来把对象转换成原始类型的值（数值、字符串和布尔值）。但是我们很少需要自己调用此函数，valueOf 方法一般都会被 JavaScript 自动调用。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("String => 返回字符串\nNumber => 返回数字\nDate => 返回时间戳\nBoolean => 返回Boolean的this值\nObject => 返回this\n")])])]),e("p",[a._v("上面两种方法都是object的方法，除了这两个方法之外，还有三个运算符：")]),a._v(" "),e("h3",{attrs:{id:"三-number运算符-尽量搞成数字"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三-number运算符-尽量搞成数字"}},[a._v("#")]),a._v(" （三）Number运算符 尽量搞成数字")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("null 转换为 0\nundefined 转换为 NaN\ntrue 转换为 1，false 转换为 0\n字符串转换时遵循数字常量规则，转换失败返回NaN\n")])])]),e("h3",{attrs:{id:"四-string运算符-全部转成字符串"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四-string运算符-全部转成字符串"}},[a._v("#")]),a._v(" （四）String运算符 全部转成字符串")]),a._v(" "),e("p",[a._v("刚才看toString的时候，null和undefined都会报错，但是String就不会报错，万物皆可转，（也不是那么绝对）但是String运算符没办法接收参数。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("String(null) // null\nstring(undefined) // undefined\n")])])]),e("h3",{attrs:{id:"五-boolean运算符-全部转成true或者false"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#五-boolean运算符-全部转成true或者false"}},[a._v("#")]),a._v(" （五）Boolean运算符 全部转成true或者false")]),a._v(" "),e("p",[a._v("Boolean也很好理解，就是转成布尔值，只需要记住，一下几种转成false，其余的全部是true就行了。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("undefined\nnull\n-0\n0或+0\nNaN\n''（空字符串）\n")])])]),e("p",[a._v("除了这六种，其余全部都是true，什么空对象，空数组全部都是true，甚至这种：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("Boolean(new Boolean(false)) // true\n")])])]),e("h3",{attrs:{id:"六-toprimitive运算符-转换成原始值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#六-toprimitive运算符-转换成原始值"}},[a._v("#")]),a._v(" (六)ToPrimitive运算符 转换成原始值")]),a._v(" "),e("p",[a._v("除了上面五种方法，js还有一个相对综合了一下的ToPrimitive，它对基础数据类型是没用的，只有引用数据类型可以。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("ToPrimitive(obj,type)\n")])])]),e("p",[a._v("ToPrimitive运算符接受一个需要转换的对象值，以及一个可选择的type值，根据这个可选的type值，来进行转换：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("type为string:\n\n先调用obj的toString方法，如果为原始值，则return，否则进行第2步\n调用obj的valueOf方法，如果为原始值，则return，否则进行第3步\n抛出TypeError 异常\n\ntype为number:\n\n先调用obj的valueOf方法，如果为原始值，则return，否则进行第2步\n调用obj的toString方法，如果为原始值，则return，否则第3步\n抛出TypeError 异常\n\ntype参数为空\n\n该对象为Date，则type被设置为String\n否则，type被设置为Number\n")])])]),e("h1",{attrs:{id:"三、隐式数据类型转换"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、隐式数据类型转换"}},[a._v("#")]),a._v(" 三、隐式数据类型转换")]),a._v(" "),e("p",[a._v("因为js是所类型语言，所以相对语法非常宽松，字符串可以和数字运算，数字还能和布尔值运算，在运算过程中就产生了隐式数据类型转换，首先，隐式转换有下面三个原则：")]),a._v(" "),e("h5",{attrs:{id:"_1、遇到-字符串连接符-就转成string类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、遇到-字符串连接符-就转成string类型"}},[a._v("#")]),a._v(" 1、遇到+（字符串连接符）就转成string类型：")]),a._v(" "),e("h5",{attrs:{id:"_2、转成number类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、转成number类型"}},[a._v("#")]),a._v(" 2、转成number类型：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("++/--(自增自减运算符) \n+ - * / %(算术运算符) \n> < >= <= == != === !=== (关系运算符)\n")])])]),e("h5",{attrs:{id:"_3、遇到-逻辑非运算符-就转成boolean类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、遇到-逻辑非运算符-就转成boolean类型"}},[a._v("#")]),a._v(" 3、遇到 !（逻辑非运算符），就转成boolean类型：")]),a._v(" "),e("p",[a._v("但是，这里面还有很多常见的坑，比如：")]),a._v(" "),e("h3",{attrs:{id:"_1、字符串拼接的-和算数运算符的-都是-到底是哪个"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、字符串拼接的-和算数运算符的-都是-到底是哪个"}},[a._v("#")]),a._v(" 1、字符串拼接的+和算数运算符的+都是+，到底是哪个？")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("常见的面试题：\n\nconsole.log(1 + 'true') // '1true'\nconsole.log(1 + true) // 2\nconsole.log(1 + null) // 1\nconsole.log(1 + undefined) // NaN\nconsole.log(null + undefined) //NaN\n")])])]),e("p",[a._v("关于字符串拼接+和算数运算符+，有个原则，只要有一边是字符串，那这个+就是字符串拼接符，其余的所有的情况都是算数运算符。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("console.log(1 + 'true') // '1true'\n\n'true'是字符串，所以是字符串拼接，只要是字符串拼接，两边都会调用String运算符\n\nconsole.log(1 + true) // 2 Number(1)+Number(true) 1+1 2\nconsole.log(1 + null) // 1 Number(1)+Number(null) 1+0 1\nconsole.log(1 + undefined) // Number(1)+Number(undefined) 0+undefined NaN\nconsole.log(null + undefined) //Number(null)+Number(undefined) 0+undefined NaN\n\n上面的没有一边是字符串，所以是运算符，如果被当做运算符，那么两边都会调用Number运算符\n")])])]),e("h3",{attrs:{id:"_2、关系运算符-为什么2-10-2-10"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、关系运算符-为什么2-10-2-10"}},[a._v("#")]),a._v(" 2、关系运算符，为什么2<'10','2'>'10'?")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("常见的面试题：\n\nconsole.log(2>'10') // false\nconsole.log('2'>'10') // true\n")])])]),e("h5",{attrs:{id:"如果关系运算符一边是字符串-那么会调用number运算符-把两边转成数字-再比较"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如果关系运算符一边是字符串-那么会调用number运算符-把两边转成数字-再比较"}},[a._v("#")]),a._v(" 如果关系运算符一边是字符串，那么会调用Number运算符，把两边转成数字，再比较")]),a._v(" "),e("h5",{attrs:{id:"如果关系运算符两边都是字符串-会用charcodeat-方法转成数字-再比较"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如果关系运算符两边都是字符串-会用charcodeat-方法转成数字-再比较"}},[a._v("#")]),a._v(" 如果关系运算符两边都是字符串，会用charCodeAt()方法转成数字，再比较")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("console.log(2>'10') // Number(2)>Number(10) 2>10 false \nconsole.log('2'>'10') //2.charCodeAt()>10.charCodeAt() 50>49 true\n")])])]),e("p",[a._v("'2'>'10'进行charCodeAt()的时候，会先比第一个字节，如果不一样，直接就返回结果，如果第一个一样会接着比第二个字节。就是2.charCodeAt()会先跟1.charCodeAt()进行比较。")]),a._v(" "),e("h3",{attrs:{id:"_3、引用数据类型在进行隐式转换的时候-会先转成string。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、引用数据类型在进行隐式转换的时候-会先转成string。"}},[a._v("#")]),a._v(" 3、引用数据类型在进行隐式转换的时候，会先转成string。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("console.log([1,2] == '1,2') //true\n\n在这个过程中[1,2]是引用数据类型，会先调用valueOf()方法\n如果返回的还是引用数据类型，再调用toString()方法\n")])])]),e("h3",{attrs:{id:"_4、逻辑非运算符和关系运算符-为啥-0-0-重点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、逻辑非运算符和关系运算符-为啥-0-0-重点"}},[a._v("#")]),a._v(" 4、逻辑非运算符和关系运算符，为啥[] == 0,![] == 0？（重点）")]),a._v(" "),e("h4",{attrs:{id:"入门级别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#入门级别"}},[a._v("#")]),a._v(" 入门级别：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("console.log([] == 0) // true\nconsole.log(![] == 0) // true\n")])])]),e("p",[a._v("为啥[]等于0,![]也等于0，这不是毁三观吗？")]),a._v(" "),e("h5",{attrs:{id:"首先分析下-0"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#首先分析下-0"}},[a._v("#")]),a._v(" 首先分析下[] == 0:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("1、在讲引用数据类型阴性转换的时候，我们说了引用数据类型进行隐形类型转换必须先转成string\n[].valueOf().toString() // ''\n\n2、==数据关系运算符，两边必须都转成Number\nNumber('') // 0\n\n所以true\n")])])]),e("h5",{attrs:{id:"然后分析下-为啥也是0"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#然后分析下-为啥也是0"}},[a._v("#")]),a._v(" 然后分析下![]为啥也是0：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("1、在讲Boolean运算符的时候说了\n除了undefined、null、-0、0或+0、NaN、''（空字符串），其余全部都是true\n所以[]是true，那么![]就是false\n\n2、两边在转Number的时候:\nNumber(false) // 0\n\n所以![] == 0也是true\n")])])]),e("h4",{attrs:{id:"进阶级别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进阶级别"}},[a._v("#")]),a._v(" 进阶级别")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("[] == ![] //true\n[] == [] // false\n")])])]),e("p",[a._v("[]等于非[]竟然是true，[]等于他自己反倒是false？")]),a._v(" "),e("h5",{attrs:{id:""}},[e("a",{staticClass:"header-anchor",attrs:{href:"#"}},[a._v("#")]),a._v(" [] == ![]")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("1、[]还是会转成string，就是'''\n2、![]还是false\n3、‘’和false都进行Number操作都是0\n\n所以相等\n")])])]),e("h5",{attrs:{id:"这是个坑"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#这是个坑"}},[a._v("#")]),a._v(" [] == []（这是个坑）")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("这个在上一篇讲栈内存的时候说了，引用数据类型在栈中存的都是地址，所以这两个肯定不一样\n")])])]),e("h4",{attrs:{id:"高阶级别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#高阶级别"}},[a._v("#")]),a._v(" 高阶级别")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("{} == !{} // false\n{} == {} // false\n")])])]),e("p",[a._v("{}和[]都是引用数据类型，为啥他是false呢？")]),a._v(" "),e("h5",{attrs:{id:"-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#-2"}},[a._v("#")]),a._v(" {} == !{}")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v('1、{}还是会转成string，但是{}转成字符串是""[object Object]"\n2、![]还是false\n3、Number(""[object Object]")和Number(false)\n\n所以不相等\n')])])]),e("h5",{attrs:{id:"-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#-3"}},[a._v("#")]),a._v(" {} = {}")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("同理，也是比较栈内存的地址，所以false\n")])])]),e("p",[a._v("关于js的数据类型，主要的就是隐性数据类型转换，会经常出错，这个系列的两篇文章主要是聊了一下js的赋值和赋址的区别、强转换以及隐性转换我们经常出现的问题。")]),a._v(" "),e("p",[a._v("个人的微信公众号：小Jerry有话说，平时会发一些技术文章和读书笔记，欢迎交流。")]),a._v(" "),e("p",[a._v("后面会持续更新一些js基础的文章，有兴趣的可以点个关注。")])])}),[],!1,null,null,null);t.default=n.exports}}]);